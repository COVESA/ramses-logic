// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_LINK_RLOGIC_SERIALIZATION_H_
#define FLATBUFFERS_GENERATED_LINK_RLOGIC_SERIALIZATION_H_

#include "flatbuffers/flatbuffers.h"

namespace rlogic_serialization {

struct Link;
struct LinkBuilder;

enum class ELogicNodeType : uint8_t {
  Script = 0,
  RamsesNodeBinding = 1,
  RamsesAppearanceBinding = 2,
  MIN = Script,
  MAX = RamsesAppearanceBinding
};

inline const ELogicNodeType (&EnumValuesELogicNodeType())[3] {
  static const ELogicNodeType values[] = {
    ELogicNodeType::Script,
    ELogicNodeType::RamsesNodeBinding,
    ELogicNodeType::RamsesAppearanceBinding
  };
  return values;
}

inline const char * const *EnumNamesELogicNodeType() {
  static const char * const names[4] = {
    "Script",
    "RamsesNodeBinding",
    "RamsesAppearanceBinding",
    nullptr
  };
  return names;
}

inline const char *EnumNameELogicNodeType(ELogicNodeType e) {
  if (flatbuffers::IsOutRange(e, ELogicNodeType::Script, ELogicNodeType::RamsesAppearanceBinding)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesELogicNodeType()[index];
}

struct Link FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LinkBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SOURCELOGICNODETYPE = 4,
    VT_TARGETLOGICNODETYPE = 6,
    VT_SOURCELOGICNODEID = 8,
    VT_TARGETLOGICNODEID = 10,
    VT_SOURCEPROPERTYNESTEDINDEX = 12,
    VT_TARGETPROPERTYNESTEDINDEX = 14
  };
  rlogic_serialization::ELogicNodeType sourceLogicNodeType() const {
    return static_cast<rlogic_serialization::ELogicNodeType>(GetField<uint8_t>(VT_SOURCELOGICNODETYPE, 0));
  }
  rlogic_serialization::ELogicNodeType targetLogicNodeType() const {
    return static_cast<rlogic_serialization::ELogicNodeType>(GetField<uint8_t>(VT_TARGETLOGICNODETYPE, 0));
  }
  uint32_t sourceLogicNodeId() const {
    return GetField<uint32_t>(VT_SOURCELOGICNODEID, 0);
  }
  uint32_t targetLogicNodeId() const {
    return GetField<uint32_t>(VT_TARGETLOGICNODEID, 0);
  }
  const flatbuffers::Vector<uint32_t> *sourcePropertyNestedIndex() const {
    return GetPointer<const flatbuffers::Vector<uint32_t> *>(VT_SOURCEPROPERTYNESTEDINDEX);
  }
  const flatbuffers::Vector<uint32_t> *targetPropertyNestedIndex() const {
    return GetPointer<const flatbuffers::Vector<uint32_t> *>(VT_TARGETPROPERTYNESTEDINDEX);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_SOURCELOGICNODETYPE) &&
           VerifyField<uint8_t>(verifier, VT_TARGETLOGICNODETYPE) &&
           VerifyField<uint32_t>(verifier, VT_SOURCELOGICNODEID) &&
           VerifyField<uint32_t>(verifier, VT_TARGETLOGICNODEID) &&
           VerifyOffset(verifier, VT_SOURCEPROPERTYNESTEDINDEX) &&
           verifier.VerifyVector(sourcePropertyNestedIndex()) &&
           VerifyOffset(verifier, VT_TARGETPROPERTYNESTEDINDEX) &&
           verifier.VerifyVector(targetPropertyNestedIndex()) &&
           verifier.EndTable();
  }
};

struct LinkBuilder {
  typedef Link Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_sourceLogicNodeType(rlogic_serialization::ELogicNodeType sourceLogicNodeType) {
    fbb_.AddElement<uint8_t>(Link::VT_SOURCELOGICNODETYPE, static_cast<uint8_t>(sourceLogicNodeType), 0);
  }
  void add_targetLogicNodeType(rlogic_serialization::ELogicNodeType targetLogicNodeType) {
    fbb_.AddElement<uint8_t>(Link::VT_TARGETLOGICNODETYPE, static_cast<uint8_t>(targetLogicNodeType), 0);
  }
  void add_sourceLogicNodeId(uint32_t sourceLogicNodeId) {
    fbb_.AddElement<uint32_t>(Link::VT_SOURCELOGICNODEID, sourceLogicNodeId, 0);
  }
  void add_targetLogicNodeId(uint32_t targetLogicNodeId) {
    fbb_.AddElement<uint32_t>(Link::VT_TARGETLOGICNODEID, targetLogicNodeId, 0);
  }
  void add_sourcePropertyNestedIndex(flatbuffers::Offset<flatbuffers::Vector<uint32_t>> sourcePropertyNestedIndex) {
    fbb_.AddOffset(Link::VT_SOURCEPROPERTYNESTEDINDEX, sourcePropertyNestedIndex);
  }
  void add_targetPropertyNestedIndex(flatbuffers::Offset<flatbuffers::Vector<uint32_t>> targetPropertyNestedIndex) {
    fbb_.AddOffset(Link::VT_TARGETPROPERTYNESTEDINDEX, targetPropertyNestedIndex);
  }
  explicit LinkBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LinkBuilder &operator=(const LinkBuilder &);
  flatbuffers::Offset<Link> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Link>(end);
    return o;
  }
};

inline flatbuffers::Offset<Link> CreateLink(
    flatbuffers::FlatBufferBuilder &_fbb,
    rlogic_serialization::ELogicNodeType sourceLogicNodeType = rlogic_serialization::ELogicNodeType::Script,
    rlogic_serialization::ELogicNodeType targetLogicNodeType = rlogic_serialization::ELogicNodeType::Script,
    uint32_t sourceLogicNodeId = 0,
    uint32_t targetLogicNodeId = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint32_t>> sourcePropertyNestedIndex = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint32_t>> targetPropertyNestedIndex = 0) {
  LinkBuilder builder_(_fbb);
  builder_.add_targetPropertyNestedIndex(targetPropertyNestedIndex);
  builder_.add_sourcePropertyNestedIndex(sourcePropertyNestedIndex);
  builder_.add_targetLogicNodeId(targetLogicNodeId);
  builder_.add_sourceLogicNodeId(sourceLogicNodeId);
  builder_.add_targetLogicNodeType(targetLogicNodeType);
  builder_.add_sourceLogicNodeType(sourceLogicNodeType);
  return builder_.Finish();
}

struct Link::Traits {
  using type = Link;
  static auto constexpr Create = CreateLink;
};

inline flatbuffers::Offset<Link> CreateLinkDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    rlogic_serialization::ELogicNodeType sourceLogicNodeType = rlogic_serialization::ELogicNodeType::Script,
    rlogic_serialization::ELogicNodeType targetLogicNodeType = rlogic_serialization::ELogicNodeType::Script,
    uint32_t sourceLogicNodeId = 0,
    uint32_t targetLogicNodeId = 0,
    const std::vector<uint32_t> *sourcePropertyNestedIndex = nullptr,
    const std::vector<uint32_t> *targetPropertyNestedIndex = nullptr) {
  auto sourcePropertyNestedIndex__ = sourcePropertyNestedIndex ? _fbb.CreateVector<uint32_t>(*sourcePropertyNestedIndex) : 0;
  auto targetPropertyNestedIndex__ = targetPropertyNestedIndex ? _fbb.CreateVector<uint32_t>(*targetPropertyNestedIndex) : 0;
  return rlogic_serialization::CreateLink(
      _fbb,
      sourceLogicNodeType,
      targetLogicNodeType,
      sourceLogicNodeId,
      targetLogicNodeId,
      sourcePropertyNestedIndex__,
      targetPropertyNestedIndex__);
}

inline const rlogic_serialization::Link *GetLink(const void *buf) {
  return flatbuffers::GetRoot<rlogic_serialization::Link>(buf);
}

inline const rlogic_serialization::Link *GetSizePrefixedLink(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<rlogic_serialization::Link>(buf);
}

inline bool VerifyLinkBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<rlogic_serialization::Link>(nullptr);
}

inline bool VerifySizePrefixedLinkBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<rlogic_serialization::Link>(nullptr);
}

inline void FinishLinkBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<rlogic_serialization::Link> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedLinkBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<rlogic_serialization::Link> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace rlogic_serialization

#endif  // FLATBUFFERS_GENERATED_LINK_RLOGIC_SERIALIZATION_H_
